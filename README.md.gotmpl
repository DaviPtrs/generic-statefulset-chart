{{ template "chart.header" . }}

{{ template "chart.deprecationWarning" . }}

{{ template "chart.badgesSection" . }}

{{ template "chart.description" . }}

A flexible Helm chart for deploying applications using Kubernetes StatefulSets with per-pod persistent volumes via `volumeClaimTemplates`.

## Features

- **StatefulSet deployment** - Provides stable network identities and persistent storage for each pod
- **Per-pod PVCs** - Each pod gets its own persistent volume using `volumeClaimTemplates`
- **Flexible configuration** - Highly configurable via values
- **Health checks** - Support for liveness and readiness probes
- **Ingress support** - Optional ingress configuration with TLS
- **Service** - Configurable service (ClusterIP, LoadBalancer, NodePort)

## Why StatefulSet?

Use StatefulSets when you need:
- Stable, unique network identifiers
- Stable, persistent storage per pod (not shared)
- Ordered, graceful deployment and scaling
- Ordered, automated rolling updates

The key advantage over Deployments with shared PVCs is that each pod in a StatefulSet gets its own PVC automatically, perfect for applications that need per-instance storage (logs, caches, databases, etc.).

{{ template "chart.homepageLine" . }}

{{ template "chart.maintainersSection" . }}

{{ template "chart.sourcesSection" . }}

{{ template "chart.requirementsSection" . }}

## Installation

### Install from Helm repository

```bash
helm repo add generic-statefulset https://daviptrs.github.io/generic-statefulset-chart/charts
helm repo update

# Install the chart
helm install my-app generic-statefulset/statefulset-app
```

### Install from local chart

```bash
# Install with default values
helm install my-app ./statefulset-app

# Install with custom values
helm install my-app ./statefulset-app -f my-values.yaml

# Install in specific namespace
helm install my-app ./statefulset-app -n production --create-namespace
```

### Using with Terraform

From Helm repository:

```hcl
resource "helm_release" "my_api" {
  name             = "my-api"
  repository       = "https://daviptrs.github.io/generic-statefulset-chart/charts"
  chart            = "statefulset-app"
  namespace        = "production"
  create_namespace = true

  values = [
    yamlencode({
      name         = "my-api"
      replicaCount = 3

      image = {
        repository = "mycompany/my-api"
        tag        = "v1.0.0"
      }

      volumeClaimTemplates = [
        {
          metadata = {
            name = "logs"
          }
          spec = {
            accessModes      = ["ReadWriteOnce"]
            storageClassName = "standard"
            resources = {
              requests = {
                storage = "5Gi"
              }
            }
          }
        }
      ]

      volumeMounts = [
        {
          name      = "logs"
          mountPath = "/var/log/app"
        }
      ]
    })
  ]
}
```

{{ template "chart.valuesSection" . }}

## Common Use Cases

### Stateful API with Persistent Logs

Deploy a REST API that needs to persist logs per instance:

```yaml
name: my-api
replicaCount: 3
image:
  repository: mycompany/api
  tag: v1.0.0
containerPort: 8080
volumeClaimTemplates:
  - metadata:
      name: logs
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: standard
      resources:
        requests:
          storage: 5Gi
volumeMounts:
  - name: logs
    mountPath: /var/log/api
```

### Application with Multiple Storage Volumes

Deploy an application that needs both data and cache storage:

```yaml
name: my-worker
replicaCount: 2
volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 20Gi
  - metadata:
      name: cache
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
volumeMounts:
  - name: data
    mountPath: /data
  - name: cache
    mountPath: /cache
```

### Lightweight Database Deployment

Deploy a small database or key-value store:

```yaml
name: redis
replicaCount: 1
image:
  repository: redis
  tag: "7-alpine"
containerPort: 6379
volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 8Gi
volumeMounts:
  - name: data
    mountPath: /data
```

## Upgrading

```bash
# Upgrade with new values
helm upgrade my-app ./statefulset-app -f my-values.yaml

# Upgrade specific values
helm upgrade my-app ./statefulset-app --set replicaCount=5

# Upgrade with new image tag
helm upgrade my-app ./statefulset-app --set image.tag=v2.0.0
```

## Uninstalling

```bash
helm uninstall my-app
```

**Important:** PVCs created by StatefulSet are NOT automatically deleted. You must manually delete them:

```bash
# List PVCs
kubectl get pvc -l app.kubernetes.io/instance=my-app

# Delete PVCs (this will delete all data!)
kubectl delete pvc -l app.kubernetes.io/instance=my-app
```

## StatefulSet vs Deployment

| Feature | StatefulSet | Deployment |
|---------|-------------|------------|
| Pod naming | Stable (app-0, app-1, app-2) | Random |
| Storage | Per-pod PVCs | Shared PVCs |
| Scaling | Ordered (sequential) | Parallel |
| Network identity | Stable DNS names | Dynamic |
| Use cases | Databases, stateful apps, per-instance storage | Stateless apps, shared storage |

## Troubleshooting

### PVCs not being created

Check that your storage class exists:
```bash
kubectl get storageclass
```

### Pods stuck in Pending

Check PVC status:
```bash
kubectl get pvc
kubectl describe pvc <pvc-name>
```

Common issues:
- Storage class doesn't exist
- Insufficient storage quota
- Volume provisioner not running

### Pod won't start after storage issues

You may need to delete and recreate the PVC. **Warning: This will delete all data!**

```bash
# Scale down to 0 replicas
kubectl scale statefulset <name> --replicas=0

# Delete the PVC
kubectl delete pvc <pvc-name>

# Scale back up (StatefulSet will recreate the PVC)
kubectl scale statefulset <name> --replicas=3
```

## Best Practices

1. **Always set resource limits** to prevent resource exhaustion
2. **Use readiness probes** to ensure traffic only goes to healthy pods
3. **Set appropriate PVC sizes** - they cannot be easily resized later
4. **Use storage classes with volume expansion** enabled if you might need to resize
5. **Test recovery scenarios** - practice scaling down and up, deleting PVCs, etc.
6. **Monitor disk usage** on PVCs to avoid running out of space
7. **Use podManagementPolicy: Parallel** only if your app can handle it
8. **Always configure backups** for important data in PVCs

{{ template "chart.valuesTableHtml" . }}
